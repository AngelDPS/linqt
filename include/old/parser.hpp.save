#ifndef PARSER_HPP
#define PARSER_HPP

#include <string>
#include <fstream>
#include <sys/stat.h>
#include <algorithm>
#include "string_util.h"

#ifdef MPI_VERSION
#define IS_WORLD_ROOT() ({ int world_rank; MPI_Comm_rank(MPI_COMM_WORLD,&world_rank); world_rank==0;})
#else
#define IS_WORLD_ROOT() (true)
#endif


using namespace std;
string TrimLine( string inLine);



int FindHeader(ifstream& infile, const string text)
{
        int line_pos=-1;
        infile.clear();
        infile.seekg (0, std::ios::beg);//Look from the start

        string  line;
        if ( infile ) // Check if file is valid
        while( getline(infile , line ) )
        if(line.find(text, 0) != string::npos)
        {
                line_pos =(int) infile.tellg() - line.size() -1;
                return line_pos;
        }
        return 0;
};


struct parser_exception { 
   int c; 
   parser_exception(int c):c(c) { } 
};
 



bool fileExists (const string& name)
{
  struct stat buffer;   
  return (stat (name.c_str(), &buffer) == 0); 
};

//This function tries to get the requested value, if it fails it return false
template <typename T>
bool try_GetValue(ifstream& infile, const string tag, T& val, string header="")
{
	string text=tag;
	std::transform(text.begin(), text.end(), text.begin(), ::tolower);
	//Look at the beginning of the file
	infile.clear();
	infile.seekg(0, std::ios::beg);
	if(header!="")
		FindHeader(infile,header);
	

	string	line; //variable to store each line of the file
	if ( infile ) // Check if file is valid
	while	(  getline(infile , line ) )
	{
		size_t 
		equ_pos,txt_pos, com_pos; //if not comment is found return the final line
	
		//tolower everything before equal
		if( (equ_pos=line.find('=', 0) )==string::npos ) equ_pos=line.size();
		std::transform(line.begin(), line.begin()+equ_pos, line.begin(), ::tolower);
		//Remove everything after a comment
		if( (com_pos=line.find('#', 0) )==string::npos ) com_pos=line.size();
		line=line.substr (0,com_pos); 

	
		if	(
				( txt_pos=line.find(text, 0) )	!= string::npos && 
				txt_pos<equ_pos
			)
		{
			string str 		= TrimLine(line.substr(equ_pos+1,line.size()));  
			infile.clear();
			infile.seekg(0, std::ios::beg);
			return str2val(str,val);
		}
	}
	infile.clear();
	infile.seekg(0, std::ios::beg);
	return false;
};


template <typename T>
bool GetValue(ifstream& infile, const string text, T& val, string header="")
{
	bool wasfound=try_GetValue(infile,text,val,header);
	if(IS_WORLD_ROOT() && !wasfound) 
		std::cout<<"Field: "<<text<<" not found in file: "<<text<<" aborting "<<std::endl;
	return wasfound;
};


template <typename T>
void  GetOptionalValue(ifstream& infile, const string text, T& val, string header="")
{
	bool wasfound=try_GetValue(infile,text,val,header);
	
	if(IS_WORLD_ROOT())
//	if(IS_WORLD_ROOT() && !wasfound) 
//		std::cout<<"The optional Field: "<<text<<" not found in file "<<text<<" keeping default "<<val<<std::endl;
	return ;
};


ifstream& GetBoolOption(ifstream& infile, const string text, bool& value)
{
	std::string Option;
	GetValue(infile,text,Option);
	std::transform(Option.begin(), Option.end(), Option.begin(), ::tolower);
	value = !((bool)Option.compare("1")*Option.compare("true"));
	return infile;
};


string RemoveComments( string inLine)
{
	//Remove coments
	size_t pos = inLine.find("#");
	string outLine = inLine.substr (0,pos-1);
return outLine;
};	


string TrimLine( string inLine)
{
	size_t pos;
	string outLine;
	string::iterator end_pos;
	//Remove coments
	pos = inLine.find("#");
	outLine = inLine.substr (0,pos-1); 
	//Remove spaces and tabulators
	end_pos = remove(outLine.begin(), outLine.end(),' ');
	outLine.erase(end_pos, outLine.end());	
	end_pos = remove(outLine.begin(), outLine.end(),'\t');
	outLine.erase(end_pos, outLine.end());	


return outLine;
};	

#endif

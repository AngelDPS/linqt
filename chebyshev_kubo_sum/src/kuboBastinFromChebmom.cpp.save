
// C & C++ libraries
#include <iostream>		/* for std::cout mostly */
#include <string>		/* for std::string class */
#include <fstream>		/* for std::ofstream and std::ifstream functions classes*/
#include <vector>		/* for std::vector mostly class*/
#include <complex>		/* for std::vector mostly class*/
#include <numeric>
#include <algorithm>

const std::complex<double> I(0,1); 


void printHelpMessage();

void printWelcomeMessage();


void cdot(const int dim, const std::complex<double>* x,const std::complex<double>* y, std::complex<double>* result)
{
	*result = 0.0;
	for(int i=0; i < dim; i++ )
		*result = std::conj(x[i])*y[i];	
	return ;
}

#include "chebyshev_moments.hpp"
#include "chebyshev_coefficients.hpp"
#include "chebyshev_kubo.hpp"

int main(int argc, char *argv[])
{	
	if (argc != 3)
	{
		printHelpMessage();
		return 0;
	}
	else
		printWelcomeMessage();


 	chebyshev::Moments2D mu(argv[2]); 
	std::string simulation_label = mu.SystemLabel(); 

	mu.ApplyJacksonKernel();

	const std::string sbroadening=argv[2];
	const double
	broadening = atof(argv[2])/1000.;

	//By performing the transformation x = Cos(theta)
	//all nodes of the matGamma matrix are equally spaced
	//on the interval (0,pi) and the separation is given by 1/M.
	//Hence, in this domain of integration, one would need at least
	// 10*M energy point to capture the oscilattion properly
	const int num_angles = 10*mu.HighestMomentNumber();
	std::vector< double >  angles(num_angles,0);
	
	const double
	xbound = 0.9,
    	theta_min = acos( xbound),
    	theta_max = acos(-xbound);
	for( int i=0; i < num_angles; i++)
		angles[i] = theta_min + i*(theta_max-theta_min)/(num_angles-1) ;


	std::string
	outputName  ="KuboBastin_sum_"+simulation_label+"_eta"+sbroadening+".dat";

	std::cout<<"Saving the data in "<<outputName<<std::endl;
	std::ofstream outputfile( outputName.c_str() );


	KuboFunctor kuboFun( mu.HighestMomentNumber() ); kuboFun.chebMoms = &mu(0,0); 
	double acc=0;
	for( std::vector< double >::iterator it =  angles.begin();
										 it!=  angles.end();
										it++)
	{
		acc += mu.SystemSize()*kuboFun(*it)/mu.HalfWidth()/mu.HalfWidth()*(theta_max-theta_min)/(num_angles-1);
		outputfile<<cos(*it)*mu.HalfWidth() + mu.BandCenter() <<" "<<acc<<std::endl;
//		outputfile<<cos(*it)*HalfWidth + BandCenter <<" "<<dim*kuboFun(*it)/HalfWidth/HalfWidth<<std::endl;
	}
	outputfile.close();

	std::cout<<"The program finished succesfully."<<std::endl;
return 0;
}
	

void printHelpMessage()
{
	std::cout << "The program should be called with the following options: moments_filename broadening(meV)" << std::endl
			  << std::endl;
	std::cout << "moments_filename will be used to look for .chebmom2D file" << std::endl;
	std::cout << "broadening in (meV) will define the broadening of the delta functions" << std::endl;
};

void printWelcomeMessage()
{
	std::cout << "WELCOME: This program will compute the chebyshev sum of the kubo-bastin formula for non equlibrium properties" << std::endl;
};
